import { Callout } from 'nextra-theme-docs';

# Hook

Hooks are the place that you can add your own code to the default behavior or DryerJS.
Below is a example of a hook that will be called before a new Tag is created. If the tag already exists, it will throw an error.

```ts copy
@Hook(() => Tag)
class TagHook implements Hook<Tag> {
  constructor(@InjectModel('Tag') private readonly Tag: Model<Tag>) {}
  
  async beforeCreate({ input }: BeforeCreateHookInput) {
    const existingTag = await this.Tag.findOne({ name: input.name });
    if (existingTag) throw new Error(`Tag with name ${input.name} already exists`);
  }
}

@Module({
  // other configs
  imports: [
    DryerModule.register({
      hooks: [TagHook],
      definitions: [Tag],
    }),
  ],
})
export class AppModule {}
```

## Interface

Below is the hook interface. You can implement any of the methods you want.

```ts copy
export interface Hook<T = any, Context = any> {
  beforeCreate?(input: { ctx: Context; input: Partial<T>; definition: Definition }): Promise<void>;

  afterCreate?(input: { ctx: Context; input: Partial<T>; created: T; definition: Definition }): Promise<void>;

  beforeUpdate?(input: {
    ctx: Context;
    input: Partial<T>;
    beforeUpdated: T;
    definition: Definition;
  }): Promise<void>;

  afterUpdate?(input: {
    ctx: Context;
    input: Partial<T>;
    updated: T;
    beforeUpdated: T;
    definition: Definition;
  }): Promise<void>;

  beforeFindOne?(input: { ctx: Context; filter: FilterQuery<T>; definition: Definition }): Promise<void>;

  afterFindOne?(input: {
    ctx: Context;
    filter: FilterQuery<T>;
    result: T;
    definition: Definition;
  }): Promise<void>;

  beforeRemove?(input: {
    ctx: Context;
    beforeRemoved: T;
    definition: Definition;
    options: RemoveOptions;
  }): Promise<void>;

  afterRemove?(input: {
    ctx: Context;
    removed: T;
    definition: Definition;
    options: RemoveOptions;
  }): Promise<void>;

  beforeFindMany?(input: {
    ctx: Context;
    filter: FilterQuery<T>;
    sort: object;
    limit?: number;
    page?: number;
    definition: Definition;
  }): Promise<void>;

  afterFindMany?(input: {
    ctx: Context;
    filter: FilterQuery<T>;
    sort: object;
    items: T[];
    limit?: number;
    page?: number;
    definition: Definition;
  }): Promise<void>;
}
```

<Callout>
  API `update` and `remove` use `findOne` under the hood so you might feel like `beforeFindOne` and `afterFindOne` are applied for `update` and `remove` too.
  If your `context` cannot `findOne` a document, you will not be able to `update` and `remove` it.
</Callout>

## Customize Context

There is a `ctx` in every hook. By default, the value is an object which looks like below.
```ts copy
{ req: express.Request }
```

### How NestJS passing context

> You can skip this sub-section if you are familiar with NestJS

In NestJS world, it's common practice to attach properties to the `request`.
In side your `Guard`, you can add `user` to `req`,
and then create a custom parameter to use it in controllers or resolvers:

```ts copy
@Injectable()
export class MustBeUser implements CanActivate {
  async canActivate(context: ExecutionContext): Promise<boolean> {
    const { req } = GqlExecutionContext.create(context).getContext();
    // getUserFromReq is a function that will get user from req
    // commonly it will parse a JWT token from header
    const user = await getUserFromReq(req);
    req.user = user;
  }
}

export const Ctx = createParamDecorator((_data: unknown, ctx: ExecutionContext) => {
  return GqlExecutionContext.create(ctx).getContext().req.user || null;
});

@Resolver(() => Tag)
export class TagResolver {
  @Query(() => Tag)
  async allTags(@Ctx() ctx: User) {
    return this.tagService.findMany({ userId: ctx.id });
  }
}
```

### Usage on DryerJS

You can set the parameter decorator that returns the context object when calling `DryerModule.register`.

```ts copy
export const Ctx = createParamDecorator((_data: unknown, ctx: ExecutionContext) => {
  return GqlExecutionContext.create(ctx).getContext().req.user || null;
});

// app.module.ts
@Module({
  imports: [
    // other imports
    DryerModule.register({
      definitions: [Tag, User],
      contextDecorator: Ctx,
    }),
  ],
})
export class AppModule {}

```

## Possible use cases

### beforeCreate & beforeUpdate

* Add custom input validation (e.g. check if email is used so we can throw a better error)
* Modify the input based on context (e.g. add `userId` from context to input so that the user does not need to input it)

### beforeFindOne & beforeFindMany

* Validate filter (e.g. check if the user has permission to see the data)
* Modify filter based on context (e.g. add `userId` from context to filter so that the user can only see their own data)

### afterFindOne & afterFindMany

* Validate the returned data (e.g. check if the user has permission to see the data)
* Modify the returned data based on context (e.g. remove some fields that the user does not have permission to see)

### afterCreate & afterUpdate & afterRemove

* Emit events (e.g. send email to user after they register)

## General Hook

You can also create a general hook that will be called for all models.

```ts copy
@Hook(() => AllDefinitions)
class GeneralHook implements Hook {
  async beforeCreate({ input }: BeforeCreateHookInput) {
    console.log(`Before create ${definition.name}`);
  }
}
```

<Callout>
  `AllDefinitions` is a special value that you can use to indicate that the hook will be called for all models which can be imported from `'dryerjs'`.
</Callout>

## Default hook

DryerJS has a default hook that will be called for all models.
It mostly used for checking relations before write operations.
It also remove related documents when remove mode is `CleanUpRelationsAfterRemoved`. See [Remove Mode](/guides/relations/remove-modes) for more details.

You can skip the default hook by setting `skipDefaultHookMethods` in `@Definition` decorator.

```ts copy
@Definition({
  skipDefaultHookMethods: [
    'beforeCreate',
    'beforeUpdate',
    'beforeRemove',
  ],
})
class Tag {}
```

<Callout>
  If you want to ignore default hook completely, you can set `{ skipDefaultHookMethods: ['all'] }`
</Callout>
